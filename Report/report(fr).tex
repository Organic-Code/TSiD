\documentclass[12pt,a4paper,twoside]{article}
\include{packages(fr)}
\include{settings(fr)}

\begin{document}
	\maketitle{}
	\renewcommand{\contentsname}{Sommaire} %redefinition of the tableofcontent title
	\tableofcontents{}
	\newpage{}
	\section{Introduction} %I
		\subparagraph*{}
			Et si nous programmions nous même un serveur et son client, en partant de rien, plutôt que d'utiliser un programme préexistant? C'est la question que nous nous sommes posés lorsque nous avons décidés de commencer ce projet. En effet, bien qu'il existe déjà de nombreux programmes pouvant faire cela — comme Apache, par exemple —, nous voulions comprendre la façon dont ces programmes fonctionnent. S'il est vrai que nous aurions pu simplement lire les sources d'Apache, nous avons pensés qu'il serait plus instructif de le refaire nous même. Ce faisant, nous devions décider de:
			\begin{itemize}
				\item{} Comment organiser les fichiers sur le serveur.
				\item{} Quelles sont les tâches respectives du client et du serveur.
				\item{} Comment ceux-ci communiquerons-t-ils.
				\item{} Quelles sont les autorisations du client.
			\end{itemize}
		\subparagraph*{}
			Afin de répondre à ses questions, nous avons longuement réfléchi, ces questions étant importantes. L'organisation des fichiers, par exemple, règle pour beaucoup la façon dont le serveur fonctionne
	\section{Description des objectifs et énoncés des problèmes} %II
		\subparagraph*{}
			L'objectif du projet TSiD est de coder un serveur et un client fonctionnels en ligne de commande, cela en utilisant la bibliothèque réseau SFML pour communiquer par internet.
			Les fonctionnalités seront les suivantes:
			\begin{itemize}
				\item{} L'accès au serveur est restreint aux membres qui possèdent un compte
				\item{} Chaque membre a accès à un dossier publique ainsi qu'a un dossier privé. Seul la personne a qui appartient le dossier privé peut y accéder
				\item{} Lorsque le client liste les fichiers d'un dossier, la date de création ainsi que le nom du créateur de chaque fichier lui sont aussi indiqués
				\item{} Un utilisateur, après avoir uploadé un fichier dans l'espace publique peut le supprimer dans les 24 heures
				\item{} Le serveur enregistre des logs de connexion
				\item{} Les utilisateurs peuvent changer de mot de passe
				\item{} Un utilisateur peut ajouter une description a un fichier qu'il a uploadé
				\item{} Un utilisateur peut créer un compte pour quelqu'un (c'est le seul moyen de créer un compte)
				\item{} Le serveur est configurable (ex: autoriser ou non aux utilisateurs l'accès a leur dossier privé)
			\end{itemize}
			Aussi, plus tard peut être, le serveur ne devra pas enregistrer les mots de passe des utilisateurs mais un hash de ceux-ci.
			Les deux programmes (client et serveur) doivent être disponibles sous les deux systèmes d'exploitation: Windows et Linux
			Pour implémenter ces fonctionnalités nous auront à résoudre les problèmes suivants:
			\begin{itemize}
				\item{} Comment communiqueront le client et le serveur? Comment traiter les commandes envoyées par le client?
				\item{} Comment traiter les accès aux dossier ainsi que les restrictions d'accès aux dossier?
				\item{} Comment récupérer la liste des dossiers et fichiers présents dans un dossier?
				\item{} Comment stocker des informations à propos des dossiers et fichiers uploadés?
				\item{} Comment afficher des informations de façon ergonomique/lisible (avec des couleurs)?
				\item{} Comment envoyer des mails via un programme?
				\item{} Comment créer, gérer et utiliser la configuration du serveur?
				\item{} Comment permettre au client de télécharger / uploader un dossier complet?
			\end{itemize}
			Nous devont résoudre chaque problème sur les deux systèmes d'exploitation (Linux \& Windows)
	\section{Solutions choisies} %III
		\subsection{Client - server: communication} %1
			\subparagraph*{}
				Afin de permettre la communication entre le client et le serveur, nous avons dû mettre en place une \textit{'grammaire standard'}. Celle-ci fonctionne de la façon suivante :
				\begin{itemize}
					\item{} Le client envoie : \textit{'Je veux faire ça, ici'}
					\item{} Le serveur essaiera ensuite de remplir la commande du client. Si cela est possible, il répondra au client \textit{'D\'accord, fait le'}, ou renverra directement la réponse attendue. Sinon, il renverra la réponse apropriée (action non autorisée, une erreur est survenue, \ldots{})
					\item{} Si le client doit effectuer une action supplémentaire (ie : téléverser un fichier), il le fera.
				\end{itemize}
			\subparagraph*{}
				For the communication at its low level, which is sending and receiving a variable, we will use \textbf{SFML/Network} library that provides the functions required to send a variable across the internet, these are: \lstinline$sf::TcpSocket::send( sf::Packet& packet )$ and \lstinline$sf::TcpSocket::receive( sf::Packet& packet )$, where a packet is an iostream.
				Here is a pseudo-code example: client wants to upload a file
			\paragraph*{Pseudo-code, client:}
				\input{III.1-algo1}
			\paragraph*{Pseudo-code, server:}
				\input{III.1-algo2}
				\input{III.1-algo3}
		\subsection{Server: Restriction d'accès} %2
			note: \textit{'./'} is the current folder, \textit{'../'} is the parent's folder.
			\subparagraph*{}
				What we basically want to do here is to avoid people to access files that are not in the server itself, but that might be, for example, at the root of the filesystem. We also want to avoid the access by a member of another member's private folder.\\
				This is easily done by analysing the path sent by the client.
			\subparagraph*{}
				For the first side of the part, we will assume that the client used by the member is the client we programmed and not a custom one, or that the member's client will have a behaviour similar to our own in term of path sending. In particular, our client is never supposed to input a \textit{'../'} or a \textit{'/..'}. As such, we just look for these sub-strings in the path, and, if we find them, we consider the client's tentative to be prohibited.
			\subparagraph*{}
				For the second part, we will use the server's folders architecture, wich is the following, the downloadable files (given foo and bar to be members):
				\begin{samepage}
					\input{III.2-server_architecture}
				\end{samepage}
			\subparagraph*{}
				File listing and client's pathing behaviour:
				\begin{itemize}
					\item{} The client starts at \textit{'/'}, but this is interpreted by the server by \textit{'/Public'}
					\item{} If the client wants to list files \& folders in \textit{'/Public'}, he sees all stuff in \textit{'./Public'} plus an extra folder, wich is \textit{'Private/'}.
					\item{} If the client wants to access \textit{'./Public/Private'}, the server should reroot him to \textit{'./Private/client\_id'} silently (the client's display will simply shows it is in \textit{'/Private'}; remember \textit{'/Public'} is \textit{'/'})
				 \end{itemize}
			\subparagraph*{}
				Given this, we will watch for the server's code, as there is not and should not be any restrictions checking from the client's side. We will also need to modify the main procedure given previously.
			\paragraph*{Pseudo-code, sever's restrictions (note that client\_id is known):}
				\input{III.2-algo1}
				\input{III.2-algo2}
		\subsection{Client: Affichage} %3
			\subparagraph*{}
				A readable display is required for the client so that the member may understand its output. For instance, if we make a really simple display like this:
				\input{III.3-ls_result1}
				This is, indeed, easy to implement. However, that's quite hard to read. Instead, we decided to:
				\begin{itemize}
					\item{} Display Files / Folders line by line
					\item{} Display firstly folders in blue, and then files in green, separated with a blank line
					\item{} Sort folders and files in alphabetical order
					\item{} Add a column with creation date and another with creator's id
				\end{itemize}
				the ouput displays looks like this:
				\input{III.3-ls_result2}
			\subparagraph*{}
				We also decided to make a \textit{'pacman style'} percentage display for downloads/uploads. For this display, we have to adapt pacman's line length to the window's length. Rules are the following:
				\begin{itemize}
					 \item{} if there is less than 3 characters available, \textit{'—'} are displayed.
					 \item{} if there is between 11 and 34 characters available, the name and the already transfered byte's number is displayed.
					 \item{} if there is between 35 and 45 characters available, the name and the number of transfered bytes over the number of bytes transfered is displayed.
					 \item{} if there is more than 45 characters available, the above is display followed by pacman style's percentage display, which takes at most 1/3 of the total available characters.
				 \end{itemize}
				Color being system dependent, the function is programmed within guards
		\subsection{Server: Stockage des informations sur les fichiers} %4
			\subparagraph*{}
				The objective is to store basic informations about uploaded files, such as the upload date and the creator.
				To do so, we will use the following architecture:
				\begin{samepage}
					\input{III.4-server_architecture}
				\end{samepage}
				Where \textit{.SomeFolders}, \textit{.SomeFiles.ext}, \ldots{} contains informations about \textit{SomeFolders/}, \textit{SomeFiles.ext}, \ldots{}
				The reason why a dot is added is so that we can write description about a folder and the folder itself in the same directory. Note that the creation of directories starting by a dot should not be allowed.
			\subparagraph*{}
				So all we need to do when foo uploads \textit{'file'} in \textit{'directory/'} (where directory is already formated as seen above) is:
				\begin{itemize}
					\item{} Write \textit{'file'} in \textit{'directory/'}
					\item{} Write the date and foo in \textit{./FilesData/directory/.file}
				\end{itemize}
				Here is a pseudo-code example, modifying the retrieveAFile procedure: (No changes to the client)
			\paragraph*{Pseudo-code, server:}
				\input{III.4-algo1}
				\input{III.4-algo2}
		\subsection{Client: upload / download récursif} %5
			\subparagraph*{}
				In order to allow the client to dowload and upload a whole folder, we decided to use a recursive approach, working as the following:
				\begin{itemize}
					\item[\textbf{1 }]{} Open the folder and see the first element it contains
					\item[\textbf{2a}]{} If it is a folder, step back to 1 with this new folder, then step forward to 3
					\item[\textbf{2b}]{} If it is a file, download/upload it, then step forward to 3
					\item[\textbf{3 }]{} Step back to 2 with the next element of the foder
				\end{itemize}
				There is the recursive download pseudo-code (no changes to the server)
			\paragraph*{Pseudo-code, client:}
				\input{III.5-algo1}
		\subsection{Server: Configuration} %6
			\subparagraph*{}
				We want to have a configuration for the server. There is a list of the configurable elements for now:
				\begin{itemize}
					\item{} Generate or not the server folders at next startup
					\item{} Create a new user or not at next startup
					\item{} Allow members to invite another member (basically: create a new account) or not
					\item{} Allow members to write in their private folders or not
					\item{} Allow members to download from their private folders or not
				\end{itemize}
			\subparagraph*{}
				To do so, we decided to create an object Config, having the following private variables:
				\begin{itemize}
					\item{} user\_creation\_allowed
					\item{} private\_folder\_writing\_allowed
					\item{} private\_folder\_reading\_allowed
				\end{itemize}
				all booleans\\
				This object will be in read-only.\\
				The first two setting do not appear in the object, as they are used only at startup.\\
				A pointer to this object will be passed to each client's thread.
		\subsection{Server, client: Message d'accueil} %7
			\subparagraph*{}
				The objective is to allow the the server owner to write a user-adjustable welcome message for all users.
				In this way we wanted to implement some variables in the welcome message, so we used the syntax \textit{'\$[variable\_name]'}, the available variables are:
				\begin{itemize}
					\item{} \textbf{user} the user name
					\item{} \textbf{date} the date formated \textit{'dd/mm/yy'}
					\item{} \textbf{day} the day formated \textit{'Mon,Tue,Wed,Thu\ldots'}
					\item{} \textbf{hour} the hour formated \textit{'hh:mm'}
					\item{} \textbf{color} to set the text color from the variable to the next color variable
				\end{itemize}
				where \textbf{color} can be blue, green, cyan, red, magenta, yellow, white.
				To put the \textit{'\$'} symbol simply put \textit{'\$\$'}
			\paragraph*{Pseudo-code, server:}
				\input{III.7-algo1}
				\input{III.7-algo2}
			\paragraph*{Pseudo-code, client:}
				\input{III.7-algo3}
				\input{III.7-algo4}
	\section{Conclusion} %IV
		\subparagraph*{}
			Ce projet fut très instructif et intéressant. La dernière version du programme pour l'UV de TZ20 et la V1 Ranitomeya reticulata, elle ne contient pas tout ce que nous aurions voulu implémenter mais les fonctionnalités les plus importantes ont été implémentées. Nous avons la volonté de continuer à travailler sur ce programme. La version actuelle peut être utilisée avec des personnes en lesquelles vous avez confiance, mais la sécurité n’ayant pas été testée nous ne recommandons pas son utilisation à plus grande échelle.
		\subsection{Améliorations possibles} %1
			\subparagraph*{}
				Certaines fonctionnalités mériteraient d'être plus développées mais ne l'ont pas été par manque de temps, par exemple:
				\begin{itemize}
					\item{} \textbf{Suppression de fichiers}\\
						Les utilisateurs peuvent uploader des fichiers et dossier mais ils ne peuvent pas les supprimer. Nous avions pensé à un système de vote ou les utilisateurs auraient pu voter pour ou contre la suppression d'un fichier.
					\item{} \textbf{Mots de passe}\\
						Les mots de passe sont enregistrés tel-quel sur le serveur ce qui n'est pas assez sécurisé. Il serait préférable de sauvegarder des hash de ces derniers.
					\item{} \textbf{Mails}\\
						Nous aurions voulu implémenter un système de mails qui aurait pu être utilisé pour:
						\begin{itemize}
							\item{} Inviter des nouveaux utilisateurs
							\item{} Prévenir les membres lorsqu'une adresse IP inconnue essaye d'accèder a leur compte
							\item{} Informer un membres lorsqu'un vote a été lancer pour la suppression d'un fichier qu'il a uploadé
						\end{itemize}
					\item{} \textbf{Filtre IP}\\
						Dans le but d'aider les utilisateurs à sécuriser leur compte, nous voudrions ajouter une vérification de l'adresse IP à la connexion. Toute IP non autorisée se verra ainsi refuser la connexion au compte. Un mail pourra être envoyé à l'utilisateur pour ajouter l'IP à la liste des adresses autorisées. L'utilisateur aurait la possibilité de désactiver ce service.
					\item{} \textbf{Admin thread}\\
						There is no way to delete a user, a file, or to change the server configuration easily, which is not nice. The problem could be solved by adding an admin console, were you could enter some commands
					\item{} \textbf{Limit private folder space usage}\\
						The goal of this server is mainly to use the public folder, so it could be nice to set a limit to the private folder, let's say 10Gio, configurable via the server's configuration
				\end{itemize}
		\subsection{Connaissances acquises} %2
			\subparagraph*{}
				What did we learn while doing this project?
				\begin{itemize}
					\item{} \textbf{Teamwork}\\
						We learned to work as a team, in a different way we did in others UV with a team presentation, such as LE03
					\item{} \textbf{Work organization}\\
						As we were working in autonomy, we had to organize us in order to meet the deadlines. We had to organize both the working order (what to do), and timing (when to do it). That may be very useful in our professional life.
					\item{} \textbf{GitHub}\\
						GitHub is a powerful tool of version gesture that helps developpers to work together on a project. This could help us as well in our active life, as we may work as developpers, and our company will probably use a similar tool
					\item{} \textbf{Strings manipulation}\\
						We learned a lot about strings [in C++], and that knowledge can easily be transfered most of others programming languages
					\item{} \textbf{Cmake}\\
						Finally, we learned about CMake, which is a powerful tool to generate MakeFiles.
				\end{itemize}
\end{document}
